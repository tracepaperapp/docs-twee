{"config":{"indexing":"full","lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"Welcome to Tracepaper # Introducing Tracepaper by Draftsman, a revolutionary tool designed to simplify the complexities of building business applications. While the landscape is rich with low-code tools to aid development, the challenges of managing these tools in production can be daunting. From maintaining performance to ensuring granular access control and backups, the operational demands can strain businesses lacking a robust engineering department. Enter serverless services offered by major cloud providers like AWS, promising to alleviate this operational burden. \"Serverless is how the cloud wants you to build applications,\" as Gregor Hohpe puts it. But is this approach practical? In practice, serverless architecture introduces a high level of runtime granularity, where each line in your domain model translates into network calls fraught with access control, latency, and security considerations. It requires a shift from operational competence to distributed system design proficiency. However, if your expertise lies in your domain rather than distributed systems intricacies, you likely prefer to reason about your domain holistically\u2014a \"Monolith,\" in industry terms. This is where Tracepaper shines, drawing inspiration from Domain Driven Design principles. We empower you to model your domain using distinct boxes connected by lines, representing various elements such as API access points, domain behaviors, and materialized views. Our modeling tool prioritizes data structures and the connections between these boxes, allowing you to focus on the essence of your domain. While we provide modeling concepts for the business logic within these boxes, the true strength lies in the ability to inject custom Python code. Transitioning from pseudo-code to Python is seamless, freeing you from concerns about the connections between your logic. Let us handle the lines, so you can concentrate on the boxes\u2014the core of your domain expertise. The model seamlessly converts into a Python project defined with CloudFormation, AWS's Infrastructure as Code specification. This ensures deployability within your AWS account, granting you full control over runtime parameters such as access and cost. Additionally, both the model and the generated project are stored in your GitHub account, offering complete oversight and ownership. With Tracepaper, we streamline the process of modeling your domain as a distributed system. Let us handle the intricacies, while you focus on what truly matters\u2014your domain.","title":"Welcome to Tracepaper"},{"location":"#welcome-to-tracepaper","text":"Introducing Tracepaper by Draftsman, a revolutionary tool designed to simplify the complexities of building business applications. While the landscape is rich with low-code tools to aid development, the challenges of managing these tools in production can be daunting. From maintaining performance to ensuring granular access control and backups, the operational demands can strain businesses lacking a robust engineering department. Enter serverless services offered by major cloud providers like AWS, promising to alleviate this operational burden. \"Serverless is how the cloud wants you to build applications,\" as Gregor Hohpe puts it. But is this approach practical? In practice, serverless architecture introduces a high level of runtime granularity, where each line in your domain model translates into network calls fraught with access control, latency, and security considerations. It requires a shift from operational competence to distributed system design proficiency. However, if your expertise lies in your domain rather than distributed systems intricacies, you likely prefer to reason about your domain holistically\u2014a \"Monolith,\" in industry terms. This is where Tracepaper shines, drawing inspiration from Domain Driven Design principles. We empower you to model your domain using distinct boxes connected by lines, representing various elements such as API access points, domain behaviors, and materialized views. Our modeling tool prioritizes data structures and the connections between these boxes, allowing you to focus on the essence of your domain. While we provide modeling concepts for the business logic within these boxes, the true strength lies in the ability to inject custom Python code. Transitioning from pseudo-code to Python is seamless, freeing you from concerns about the connections between your logic. Let us handle the lines, so you can concentrate on the boxes\u2014the core of your domain expertise. The model seamlessly converts into a Python project defined with CloudFormation, AWS's Infrastructure as Code specification. This ensures deployability within your AWS account, granting you full control over runtime parameters such as access and cost. Additionally, both the model and the generated project are stored in your GitHub account, offering complete oversight and ownership. With Tracepaper, we streamline the process of modeling your domain as a distributed system. Let us handle the intricacies, while you focus on what truly matters\u2014your domain.","title":"Welcome to Tracepaper"},{"location":"WriteDomain/","text":"Write Domain # Introduction # The Write Domain is a fundamental part of our model-driven development environment. It focuses on processing and recording data within a system. This domain encompasses all components responsible for invoking and executing behaviors that change the state of the application. The Write Domain is essential for maintaining the integrity and consistency of data. Components of the Write Domain # The Write Domain consists of several key components: Commands, Behavior Flows, and Automations. Each of these components plays a specific role in capturing and processing events and actions that affect the state of the application. Commands # Commands represent interactions from users or systems with the application. These events are triggered by actions of actors (such as users or external systems) and initiate changes in the application's state. Example : An InitializeBookRequested command might be generated when a user wants to initialize a new book. This command contains all the necessary information such as the book's title, the repository URL, and the owner. Behavior Flows # Behavior Flows are the core of the Write Domain. They model the data structures and behavior patterns that govern the application's state. A behavior flow encapsulates a set of related objects and ensures data consistency within its boundaries. The only way to change the state of a behavior flow is by executing commands defined by the behavior flow. Example : The Book behavior flow contains fields such as title and repository , and defines an Initialize behavior flow that is triggered by the InitializeBookRequested command. This behavior flow executes the necessary logic to handle the initialization of a book. Automations # Automations are responsible for performing specific actions when certain conditions or events occur. They are often used for system activities that need to take place in response to specific events within the Write Domain. Automations can fail silently if necessary, meaning that the failure of an automation does not critically impact the application. Example : The InitializeSystemUser automation is triggered after the application deployment to create a system user. This occurs via a trigger activated after deployment ( @afterDeployment ). Purpose and Benefits of the Write Domain # The Write Domain plays a crucial role in ensuring the integrity and consistency of data within an application. By strictly separating data and behavior logic, the Write Domain offers the following benefits: Consistency : By encapsulating data and behavior within behavior flows, it ensures that changes are applied consistently and atomically. Traceability : Commands provide a clear and auditable trail of all actions and events that lead to changes in the application's state. Maintainability : By separating different responsibilities (commands, behavior flows, automations), complexity is reduced, making the code more maintainable and extendable. Conclusion # The Write Domain is an essential concept within our model-driven development environment. It provides a clear structure and maintains the integrity of the application through well-defined components such as Commands, Behavior Flows, and Automations. By effectively using these components, we can build robust, consistent, and well-maintained applications.","title":"Index"},{"location":"WriteDomain/#write-domain","text":"","title":"Write Domain"},{"location":"WriteDomain/#introduction","text":"The Write Domain is a fundamental part of our model-driven development environment. It focuses on processing and recording data within a system. This domain encompasses all components responsible for invoking and executing behaviors that change the state of the application. The Write Domain is essential for maintaining the integrity and consistency of data.","title":"Introduction"},{"location":"WriteDomain/#components-of-the-write-domain","text":"The Write Domain consists of several key components: Commands, Behavior Flows, and Automations. Each of these components plays a specific role in capturing and processing events and actions that affect the state of the application.","title":"Components of the Write Domain"},{"location":"WriteDomain/#commands","text":"Commands represent interactions from users or systems with the application. These events are triggered by actions of actors (such as users or external systems) and initiate changes in the application's state. Example : An InitializeBookRequested command might be generated when a user wants to initialize a new book. This command contains all the necessary information such as the book's title, the repository URL, and the owner.","title":"Commands"},{"location":"WriteDomain/#behavior-flows","text":"Behavior Flows are the core of the Write Domain. They model the data structures and behavior patterns that govern the application's state. A behavior flow encapsulates a set of related objects and ensures data consistency within its boundaries. The only way to change the state of a behavior flow is by executing commands defined by the behavior flow. Example : The Book behavior flow contains fields such as title and repository , and defines an Initialize behavior flow that is triggered by the InitializeBookRequested command. This behavior flow executes the necessary logic to handle the initialization of a book.","title":"Behavior Flows"},{"location":"WriteDomain/#automations","text":"Automations are responsible for performing specific actions when certain conditions or events occur. They are often used for system activities that need to take place in response to specific events within the Write Domain. Automations can fail silently if necessary, meaning that the failure of an automation does not critically impact the application. Example : The InitializeSystemUser automation is triggered after the application deployment to create a system user. This occurs via a trigger activated after deployment ( @afterDeployment ).","title":"Automations"},{"location":"WriteDomain/#purpose-and-benefits-of-the-write-domain","text":"The Write Domain plays a crucial role in ensuring the integrity and consistency of data within an application. By strictly separating data and behavior logic, the Write Domain offers the following benefits: Consistency : By encapsulating data and behavior within behavior flows, it ensures that changes are applied consistently and atomically. Traceability : Commands provide a clear and auditable trail of all actions and events that lead to changes in the application's state. Maintainability : By separating different responsibilities (commands, behavior flows, automations), complexity is reduced, making the code more maintainable and extendable.","title":"Purpose and Benefits of the Write Domain"},{"location":"WriteDomain/#conclusion","text":"The Write Domain is an essential concept within our model-driven development environment. It provides a clear structure and maintains the integrity of the application through well-defined components such as Commands, Behavior Flows, and Automations. By effectively using these components, we can build robust, consistent, and well-maintained applications.","title":"Conclusion"},{"location":"aggregate/01%20aggregate/","text":"The Aggregate Concept # An aggregate reflects a domain concept, a collection of data (state) and behavior to manipulate the data. The data is internally encapsulated, so the only way to induce a state change is by invoking behavior. Modeling an aggregate involves two activities: 1. Modeling the data model. 2. Modeling behavior on the model. A concept from DDD opinionated to optimize cognitive load, focusing on the concepts rather than the underlying technology. It abstracts the Command/Compute part of our CQRS architecture.","title":"The Aggregate Concept"},{"location":"aggregate/01%20aggregate/#the-aggregate-concept","text":"An aggregate reflects a domain concept, a collection of data (state) and behavior to manipulate the data. The data is internally encapsulated, so the only way to induce a state change is by invoking behavior. Modeling an aggregate involves two activities: 1. Modeling the data model. 2. Modeling behavior on the model. A concept from DDD opinionated to optimize cognitive load, focusing on the concepts rather than the underlying technology. It abstracts the Command/Compute part of our CQRS architecture.","title":"The Aggregate Concept"},{"location":"aggregate/02%20data%20model/","text":"Aggregate Data Model # The data model consists of two parts, the actual part: the events , and the projection: the document . The Document # The document is a projection of the data, a mental model of the state so that we can implement validations in the behavior to ensure data integrity. Because it is a projection, this model can evolve over time without manipulating the underlying data. Events from the past are immutable by definition. Thus, the document serves both as a mental model for ourselves on how we want to think about state and as a way to model how we present data to the viewstore. It is the data contract between the aggregate and the viewstore. The Events # The domain events are the recording of facts. They reflect a bundle of data that encompasses the delta between two states. Therefore, the state is not stored in the database, merely a log of deltas that exist alongside each other on a timeline. This is called the event log. Event Handling # To populate our mental model, the projection, we need event handlers. These model the mapping between the event log and the document. Side Notes on Views # Views will be discussed later, but regarding the contract, the viewstore essentially models the external contract, the GraphQL API. So while the document is a data contract, this contract remains within the domain. The viewstore can do various things with the data: Store As Is # Essentially caching a snapshot of the aggregate state. In this case, the internal model becomes publicly accessible, being queryable and read-optimized. Enrich and Store # Enrichment can take various forms, such as combining data from different aggregates into one document or modifying data for storage, i.e., determining derived data and caching it in the viewstore. Enrich During Data Reading # Modifying the API response before it is sent to the client. This involves executing logic on the combination of request data and cached data. Essentially, this is an on-the-fly projection where the view model is virtual. The logic has access to the request data and a fluent API to the viewstore, allowing the creation of a response object using Python scripting from this combination.","title":"Aggregate Data Model"},{"location":"aggregate/02%20data%20model/#aggregate-data-model","text":"The data model consists of two parts, the actual part: the events , and the projection: the document .","title":"Aggregate Data Model"},{"location":"aggregate/02%20data%20model/#the-document","text":"The document is a projection of the data, a mental model of the state so that we can implement validations in the behavior to ensure data integrity. Because it is a projection, this model can evolve over time without manipulating the underlying data. Events from the past are immutable by definition. Thus, the document serves both as a mental model for ourselves on how we want to think about state and as a way to model how we present data to the viewstore. It is the data contract between the aggregate and the viewstore.","title":"The Document"},{"location":"aggregate/02%20data%20model/#the-events","text":"The domain events are the recording of facts. They reflect a bundle of data that encompasses the delta between two states. Therefore, the state is not stored in the database, merely a log of deltas that exist alongside each other on a timeline. This is called the event log.","title":"The Events"},{"location":"aggregate/02%20data%20model/#event-handling","text":"To populate our mental model, the projection, we need event handlers. These model the mapping between the event log and the document.","title":"Event Handling"},{"location":"aggregate/02%20data%20model/#side-notes-on-views","text":"Views will be discussed later, but regarding the contract, the viewstore essentially models the external contract, the GraphQL API. So while the document is a data contract, this contract remains within the domain. The viewstore can do various things with the data:","title":"Side Notes on Views"},{"location":"aggregate/02%20data%20model/#store-as-is","text":"Essentially caching a snapshot of the aggregate state. In this case, the internal model becomes publicly accessible, being queryable and read-optimized.","title":"Store As Is"},{"location":"aggregate/02%20data%20model/#enrich-and-store","text":"Enrichment can take various forms, such as combining data from different aggregates into one document or modifying data for storage, i.e., determining derived data and caching it in the viewstore.","title":"Enrich and Store"},{"location":"aggregate/02%20data%20model/#enrich-during-data-reading","text":"Modifying the API response before it is sent to the client. This involves executing logic on the combination of request data and cached data. Essentially, this is an on-the-fly projection where the view model is virtual. The logic has access to the request data and a fluent API to the viewstore, allowing the creation of a response object using Python scripting from this combination.","title":"Enrich During Data Reading"},{"location":"expressions/01%20actor%20event%20role/","text":"API Authorization Expression # The authorization expression can be used in all components exposed in the API: Commands View queries It is used to convert an input parameter (command field or query filter field, e.g., key, key_begins_with, or a custom filter attribute) to a technical role that the API resolver will validate to determine if the requester has the specific role. This is useful for providing role-based access in a multi-tenant system. The expression has a name , e.g., extractRoleFromArn , which is used to access the expression from command models or view models. You model inputs for this function separated with a ; e.g., arn;role And then use Velocity Template Language (VTL) syntax with basic JavaScript to model the logic: ${arn.split(':')[0]}:${arn.split(':')[1]}:role In a command or view query, you can use this expression in the role field when you select role-based access: #global.extractRoleFromArn(key, 'viewer') When you execute, for example, a query where this is implemented, it will evaluate to: #foreach($group in $context.identity.claims.get(\"cognito:groups\")) #if($group == \"${ctx.args.key.split(':')[0]}:${ctx.args.key.split(':')[1]}:viewer\") #set($inCognitoGroup = true) #end #end #if($inCognitoGroup){ \"version\": \"2018-05-29\", \"operation\": \"GetItem\", \"key\": { \"type\": $util.dynamodb.toDynamoDBJson(\"ViewName\"), \"key\": $util.dynamodb.toDynamoDBJson($ctx.args.key) } } #else $utils.unauthorized() #end","title":"API Authorization Expression"},{"location":"expressions/01%20actor%20event%20role/#api-authorization-expression","text":"The authorization expression can be used in all components exposed in the API: Commands View queries It is used to convert an input parameter (command field or query filter field, e.g., key, key_begins_with, or a custom filter attribute) to a technical role that the API resolver will validate to determine if the requester has the specific role. This is useful for providing role-based access in a multi-tenant system. The expression has a name , e.g., extractRoleFromArn , which is used to access the expression from command models or view models. You model inputs for this function separated with a ; e.g., arn;role And then use Velocity Template Language (VTL) syntax with basic JavaScript to model the logic: ${arn.split(':')[0]}:${arn.split(':')[1]}:role In a command or view query, you can use this expression in the role field when you select role-based access: #global.extractRoleFromArn(key, 'viewer') When you execute, for example, a query where this is implemented, it will evaluate to: #foreach($group in $context.identity.claims.get(\"cognito:groups\")) #if($group == \"${ctx.args.key.split(':')[0]}:${ctx.args.key.split(':')[1]}:viewer\") #set($inCognitoGroup = true) #end #end #if($inCognitoGroup){ \"version\": \"2018-05-29\", \"operation\": \"GetItem\", \"key\": { \"type\": $util.dynamodb.toDynamoDBJson(\"ViewName\"), \"key\": $util.dynamodb.toDynamoDBJson($ctx.args.key) } } #else $utils.unauthorized() #end","title":"API Authorization Expression"},{"location":"expressions/02%20trigger%20key%20expression/","text":"Trigger Key Expression # The key expression is usable in all identity-based triggers: Aggregate behavior flows View data sources It is used to convert an event attribute into a functional key. The name of the expression, e.g., truncateArn , is used to access this expression from a behavior or data-source model. You can model input for the expression, e.g., arn;length . The expression itself is written in pure Python, e.g., ':'.join(arn.split(':')[:int(length)]) You can access it by configuring a method call inside the key field of behavior or data-source. The input parameters will reference a trigger attribute. You can use literals, but they can only be strings. In our case, the expression will evaluate the string to an integer. #global.truncateArn(childArn, '2') Let's say that the trigger contains an attribute childArn=draftsmanid:workspace:project , then the resulting key for the flow will be draftsmanid:workspace .","title":"Trigger Key Expression"},{"location":"expressions/02%20trigger%20key%20expression/#trigger-key-expression","text":"The key expression is usable in all identity-based triggers: Aggregate behavior flows View data sources It is used to convert an event attribute into a functional key. The name of the expression, e.g., truncateArn , is used to access this expression from a behavior or data-source model. You can model input for the expression, e.g., arn;length . The expression itself is written in pure Python, e.g., ':'.join(arn.split(':')[:int(length)]) You can access it by configuring a method call inside the key field of behavior or data-source. The input parameters will reference a trigger attribute. You can use literals, but they can only be strings. In our case, the expression will evaluate the string to an integer. #global.truncateArn(childArn, '2') Let's say that the trigger contains an attribute childArn=draftsmanid:workspace:project , then the resulting key for the flow will be draftsmanid:workspace .","title":"Trigger Key Expression"}]}